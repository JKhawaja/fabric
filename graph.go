package fabric

type Graph struct {
	Nodes []int
	Edges map[int][]int // each node has a list of nodes that it points too
}

// TODO: should this function be passed a list of node int IDs generated by the user
// OR should the user be expected to just do a myGraph.Nodes = myList after creating an empty graph (??)
// What will be some techniques for generating a graph via partial orderings (?)
func NewGraph() *Graph {
	var nodes []int
	return &Graph{
		Nodes: nodes,
		Edges: make(map[int][]int),
	}
}

func (g *Graph) CycleDetect() bool {
	var unseen []int
	var seen []int
	var done []int
	var starting_node int

	seen = g.Nodes
	return g.dfs(starting_node, seen, unseen, done)
}

func (g *Graph) GetAdjacents(node int) []int {

	var adjacents []int

	for i, v := range g.Edges {
		if i == node {
			adjacents = append(adjacents, v...)
		}
	}

	return adjacents
}

/* Recursive Depth-First-Search Function */
func (g *Graph) dfs(start, seen, unseen, done []int) bool {
	// TODO:
	// move start node into seen
	// get adjacent nodes for start node (nodes that start points to) -- from edges
	// range adjacent nodes
	//		if node is in done (continue)
	//		if node is in seen (return true)
	//		if dfs(node, seen, unseen, done) (return true)
	// move current node from seen to done
	// return false
}
