package fabric

import (
	"reflect"
)

type Signal int

const (
	Waiting Signal = iota
	Started
	Complete
	Abort
	AbortRetry
	// TODO: PartialAbort (??)
)

type NodeType int

const (
	UINode NodeType = iota
	TemporalNode
	VUINode
	VirtualNode
)

// Dependency Graph Node
// every DGNode has an id, a state, and a set of Access Procedures
type DGNode interface {
	ID() int
	Type() NodeType // specifies whether node is UI, VUI, etc.
	State() Signal
	Priority() int // not necessary, but can be useful
	ListProcedures() ProcedureList
	Dependents() []DGNode
	Dependencies() []DGNode
	IsRootBoundary() bool // Autogenerated
	IsLeafBoundary() bool // Autogenerated
}

/*

AUTOGENERATED METHOD IMPLEMENTATIONS

func (d *DGNode) IsRootBoundary() bool {
	if len(d.Dependents()) == 0 {
		return true
	}

	return false
}

func (d *DGNode) IsLeafBoundary() bool {
	if len(d.Dependencies()) == 0 {
		return true
	}

	return false
}
*/

// Graph can be either UI DDAG, Temporal DAG or VDG
type Graph struct {
	CDS
	Nodes []DGNode
	Edges map[DGNode][]DGNode // each node (id) has a list of node ids that it points too
}

// NewGraph creates a new empty graph
func NewGraph() *Graph {
	var nodes []DGNode
	return &Graph{
		Nodes: nodes,
		Edges: make(map[DGNode][]DGNode),
	}
}

// CycleDetect will check whether a graph has cycles or not
func (g *Graph) CycleDetect() bool {
	var seen []DGNode
	var done []DGNode

	for _, v := range g.Nodes {
		if !contains(done, v) {
			result, _ := g.cycleDfs(v, seen, done)
			if result {
				return true
			}
		}
	}
	return false
}

// GetAdjacents will return the list of nodes a supplied node points too
func (g *Graph) GetAdjacents(node DGNode) []DGNode {
	return g.Edges[node]
}

// Recursive Depth-First-Search; used for Cycle Detection
func (g *Graph) cycleDfs(start DGNode, seen, done []DGNode) (bool, []DGNode) {
	seen = append(seen, start)
	adj := g.Edges[start]
	for _, v := range adj {
		if contains(done, v) {
			continue
		}

		if contains(seen, v) {
			return true, done
		}

		if result, done := g.cycleDfs(v, seen, done); result {
			return true, done
		}
	}
	seen = seen[:len(seen)-1]
	done = append(done, start)
	return false, done
}

// Totality-Uniqueness check for the UI nodes of a graph...
// should only be called once when creating the UI dependency graph;
// can be called with the creation of each UI if needed for
// more "real-time" verification.
func (g *Graph) TotalityUnique() bool {
	// grab all UI nodes
	uiSlice := make([]DGNode, 0)
	for _, v := range g.Nodes {
		if v.Type() == UINode {
			uiSlice = append(uiSlice, v)
		}
	}

	for i, n := range uiSlice {
		// compare the UI to all other UIs
		for i2, n2 := range g.Nodes {
			if i != i2 {
				// if UI is same as other UI return false
				// i.e. graph is not totality-unique
				if reflect.DeepEqual(n, n2) {
					return false
				}
			}
		}
	}

	return true
}

// Covered returns true if all CDS nodes and edges are covered
func (g *Graph) Covered() bool {
	// TODO: returns whether or not every node and edge is addressed
	//		by at least one UI in our UI ddag.

	// grab all UI nodes
	uiSlice := make([]UI, 0)
	for _, v := range g.Nodes {
		if v.Type() == UINode {
			uiSlice = append(uiSlice, v.(UI))
		}
	}

	// grab all CDS nodes and edges
	nodes := g.ListNodes()
	edges := g.ListEdges()

FIRST:
	// for every node in the CDS
	for _, v := range nodes {
		// check that at least one UI contains it
		for _, u := range uiSlice {
			s := u.Section()
			uiCDSNodes := s.ListNodes()
			// if UI contains node; check next CDS node
			if uiContainsNode(uiCDSNodes, v) {
				continue FIRST
			}
		}
		// if CDS node is checked in every UI and does not show up
		return false
	}

SECOND:
	// for every edge in the CDS
	for _, v := range edges {
		// check that at least one UI contains it
		for _, u := range uiSlice {
			s := u.Section()
			uiCDSEdges := s.ListEdges()
			// if UI contains edge; check next CDS edge
			if uiContainsEdge(uiCDSEdges, v) {
				continue SECOND
			}
		}

		// if CDS edge is checked in every UI and does not show up
		return false
	}

	return true
}

func (g *Graph) AddVUI(node UI) {
	// TODO: add node to nodes list
	// 		verify that node id is not already in list
}

func (g *Graph) RemoveVUI(node UI) {
	// TODO: add node to nodes list
	// 		verify that node id is not already in list
}

func (g *Graph) AddVirtual(node Virtual) {
	// TODO: add node to nodes list
	// 		verify that node id is not already in list
}

func (g *Graph) RemoveVirtual(node Virtual) {
	// TODO:
	// 		remove node from node list
	// 		remove all of nodes edges from edges map
}

// FIXME: Virtual Edges will be dynamic and will cause a lot of
//		slice copying (when a virtual node has a real dependent)
//		for the real dependent node. This will especially hold true
//		for when that real node has multiple virtual dependencies.
// AppendEdge adds an edge that points from dependent to dependency
func (g *Graph) AddVirtualEdge(source, dest DGNode) {
	// TODO: add an edge to edges map which is source dependent on destination
}

func (g *Graph) RemoveVirtualEdge(source, dest DGNode) {
	// TODO: removes the edge between source and dest in the edges map
}

func (g *Graph) AppendVDG(graph Graph) {
	// TODO:
	// 		add all nodes in new graph to existing graph
	// 		add all edges in new graph to existing graph
	// 		cycle detection on new total graph.
}

func (g *Graph) RemoveVDG(nodes []DGNode) {
	// TODO: removes list of nodes and all their edges
	//		(that they are sources for).
}

// TODO: Check that all VUIs dependents lists do not get shorter
//		over the course of their lifespan. If a dependent has ended
//		its lifecycle before a VUI finishes it's lifespan then the
//		VUI needs to abort its operation.
func (g *Graph) CheckVUIDependents() bool {
	// TODO: check the dependents of a VUI node to be sure
	//		that they are all still in existence
	return false
}
